\begin{problem}{RLE + KMP}{rle.in}{rle.out}{2 секунды}

Алгоритм сжатия RLE работает следующим образом: рассмотрим
строку $s$ длины $n$, состоящую из маленьких букв латинского алфавита.
Разрешается заменить блок из $k$ последовательных одинаковых букв
$x$ на строку $kx$. Фрагмент $kx$, а также отдельный
символ, называется \emph{блоком RLE}, $k$ называется 
\emph{множителем}.

Например, строка <<\t{abbbbcccadddddaa}>> может
быть закодирована как <<\t{a4b3ca5d2a}>>.

Напомним, что \emph{префикс-функцией} называется функция
$\pi:\{1,\ldots, n\}\rightarrow\mathbb{Z}$, определенная
соотношением
$$\pi(i)=\max\{j|0\le j<i, s[1\ldots j]=s[i-j+1\ldots i]\}.$$

Задана строка, сжатая по алгоритму RLE и $m$ запросов
$q_i$. Для каждого запроса выведите $\pi(q_i)$.

\InputFile

Первая строка содержит сжатую по алгоритму RLE строку. Строка
содержит не более $50\,000$ блоков RLE. Каждый множитель
не превышает $10^9$.

Вторая строка содержит число $m$ ($1 \le m \le 100\,000$).
Далее следует $m$ чисел в интервале от 1 до длины строки,
заданной первой строкой.

\OutputFile

Для каждого запроса $q_i$ во выходном файле выведите одно число ---
$\pi(q_i)$.

\Examples

\begin{example}%
\exmp{
3a3b4a2b
5
1 3 4 10 12
}{
0
2
0
3
5
}%
\end{example}

\end{problem}
