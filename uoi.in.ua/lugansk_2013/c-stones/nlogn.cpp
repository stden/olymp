#define maxn 200000

#include <stdio.h>
#include <algorithm>

using namespace std;

int n, m, i, op, t, w;
int c[maxn];    // Загальна кількість камінців, що впадуть у кожному місті
int ws[maxn];   // Спільний масив мас камінців з усіх міст
int ws_start[maxn]; // ws_start[i] — індекс у масиві ws, з якого починається частина масиву, що відповідає місту i, 0 <= i < m
int cnt[maxn];  // Кількість наявних у даний момент камінців у кожному місті
pair<int, int> heap2[maxn]; // Масив (бінарна купа) найменших мас камінців у кожному місті (де є хоча б один камінець) разом із містами, з яких вони походять
int heap2_town_index[maxn]; // heap2_town_index[i] — індекс у масиві heap2 елемента, що відповідає камінцю з міста i (або -1, якщо в i-му місті немає жодного камінця), 0 <= i < m
int cnt2;   // Лічильник кількості елементів у купі другого рівня

/*
Повертає вагу камінця з даним номером у даному місті.
town — номер міста (від 0 до m-1)
place — номер місця (від 0 до cnt[town]-1)
*/
inline int getW(int town, int place)
{
    return ws[ws_start[town] + place];
}

/*
Задає вагу камінця з даним номером у даному місті.
town — номер міста (від 0 до m-1)
place — номер місця
w — вага камінця
*/
inline void setW(int town, int place, int w)
{
    ws[ws_start[town] + place] = w;
}

/*
Обмінює місцями маси двох камінців у даному місті.
town — номер міста (від 0 до m-1)
place1, place2 — номери місць (від 0 до cnt[town]-1)
*/
inline void swap_within_town(int town, int place1, int place2)
{
    int tmp = getW(town, place1);
    setW(town, place1, getW(town, place2));
    setW(town, place2, tmp);
}

/*
Вставляє камінець заданої ваги із заданого міста в купу другого рівня.
w — вага камінця
town_from — номер міста, з якого походить камінець (від 0 до m-1)
*/
inline void insert2(int w, int town_from)
{
    heap2[cnt2].first = w;  // Вставляємо в кінець купи другого рівня інформацію про камінець
    heap2[cnt2].second = town_from;
    heap2_town_index[town_from] = cnt2; // Оновлюємо індекс місця у купі для міста, з якого походить камінець
    int cur = cnt2, newCur; // Змінні, необхідні для підйому елемента (див. нижче)
    cnt2++; // Збільшуємо на 1 лічильник елементів у купі
    while (cur > 0 && heap2[cur].first > heap2[newCur = (cur - 1) / 2].first)   // Піднімаємо елемент, поки він не опиниться на «своєму» місці
    {
        swap(heap2_town_index[heap2[cur].second], heap2_town_index[heap2[newCur].second]);  // Разом із самими елементами купи необхідно поміняти місцями їхні індекси
        swap(heap2[cur], heap2[newCur]);
        cur = newCur;
    }
}

/*
Опускає (щойно зменшений) елемент купи другого рівня, поки він не опиниться на «своєму» місці.
index — елемент купи, який необхідно опустити (від 0 до cnt2-1)
*/
inline void descend2(int index)
{
    int cur = index, max, left, right;
    while (true)
    {
        left = 2 * cur + 1;
        right = left + 1;
        max = cur;
        if (left < cnt2 && heap2[left].first > heap2[max].first)
            max = left;
        if (right < cnt2 && heap2[right].first > heap2[max].first)
            max = right;
        if (max != cur)
        {
            swap(heap2_town_index[heap2[cur].second], heap2_town_index[heap2[max].second]); // Разом із самими елементами купи необхідно поміняти місцями їхні індекси
            swap(heap2[cur], heap2[max]);
            cur = max;
        } else
            break;
    }
}

/*
Зменшує елемент купи другого рівня, який відповідає даному місту, до заданої ваги та відновлює структуру купи.
w — нова вага
town_from — місто (від 0 до m-1), відповідний якому елемент треба зменшити
*/
inline void update2(int w, int town_from)
{
    heap2[heap2_town_index[town_from]].first = w;   // Зменшення
    descend2(heap2_town_index[town_from]);  // Відновлення структури купи
}

/*
Додає до купи першого рівня, що відповідає даному місту, нову вагу та в разі необхідності оновлює відповідним чином купу другого рівня.
town — місто (від 0 до m-1), до купи якого потрібно додати вагу
w — вага камінця
*/
inline void insert(int town, int w)
{
    setW(town, cnt[town], w);   // Додаємо вагу в масив, що відповідає купі
    int cur = cnt[town], newCur;    // Змінні, необхідні для підйому елемента (див. нижче)
    cnt[town]++;    // Збільшуємо на 1 лічильник кількості елементів у купі
    while (cur > 0 && getW(town, cur) < getW(town, newCur = (cur - 1) / 2)) // Піднімаємо елемент, поки він не опиниться на «своєму» місці
    {
        swap_within_town(town, cur, newCur);
        cur = newCur;
    }
    if (cur == 0)   // Якщо доданий елемент єдиний у місті або є новим найменшим елементом
    {
        if (cnt[town] == 1) // Якщо доданий елемент єдиний у місті, додаємо його до купи другого рівня
            insert2(w, town);
        else    // Інакше (якщо елемент є новим найменшим), оновлюємо камінець, що відповідає даному місту, в купі другого рівня
            update2(w, town);
    }
}

/*
Видаляє верхній елемент купи першого рівня, що відповідає даному місту.
town — номер міста (від 0 до m-1)
*/
inline void remove(int town)
{
    setW(town, 0, getW(town, cnt[town] - 1));   // Переміщаємо останній елемент купи на перше місце
    cnt[town]--;    // Зменшуємо на 1 лічильник кількості елементів у купі
    int cur = 0, min, left, right;
    while (true)    // Опускаємо переміщений елемент, поки він не опиниться на «своєму» місці
    {
        left = 2 * cur + 1;
        right = left + 1;
        min = cur;
        if (left < cnt[town] && getW(town, left) < getW(town, min))
            min = left;
        if (right < cnt[town] && getW(town, right) < getW(town, min))
            min = right;
        if (min != cur)
        {
            swap_within_town(town, cur, min);
            cur = min;
        } else
            break;
    }
}

/*
Видаляє верхній елемент купи другого рівня, а також відповідний йому елемент купи першого рівня; додає новий верхній елемент купи першого рівня (якщо такий є) до купи другого рівня.
Повертає вагу видаленого елемента.
*/
inline int remove2()
{
    int result = heap2[0].first;    // Вага елемента, який ми збираємось видалити
    int town_from = heap2[0].second;    // З якого міста походить елемент, який ми збираємось видалити
    swap(heap2[0], heap2[cnt2 - 1]);    // Обмінюємо місцями перший та останній елемент купи
    heap2_town_index[heap2[0].second] = 0;  // Оновлюємо індекс для міста, з якого походить колись останній, а тепер перший елемент купи
    heap2_town_index[heap2[cnt2 - 1].second] = -1;  // Оновлюємо індекс для міста, з якого походить елемент, що ми відкинемо (якщо після видалення цього елемента з купи першого рівня відповідного міста там залишиться хоча б один елемент, цей індекс буде відновлено після виклику insert2 — див. нижче)
    cnt2--; // Зменшуємо на 1 лічильник кількості елементів у купі
    descend2(0);    // Відновлюємо структуру купи

    remove(town_from);  // Видаляємо елемент з його купи першого рівня
    if (cnt[town_from] > 0) // Якщо в цій купі першого рівня лишився хоча б один елемент, додаємо новий її найменший елемент до купи другого рівня
        insert2(getW(town_from, 0), town_from);

    return result;  // Повертаємо вагу видаленого елемента
}

int main()
{
    freopen("stones.dat", "r", stdin);
    freopen("stones.sol", "w", stdout);

    scanf("%d%d", &n, &m);

    /* Заповнюємо масив c */
    for (i = 0; i < m; i++) // Ініціалізація
        c[i] = 0;
    for (i = 0; i < n; i++) // Підрахунок камінців
    {
        scanf("%d", &op);
        if (op == 1)
        {
            scanf("%d%d", &t, &w);
            t--;    // Нумерація міст у програмі з нуля, а у вхідному файлі — з одиниці
            c[t]++;
        }
    }
    /* Масив c заповнено */

    /* На основі масиву c заповнюємо масив ws_start */
    ws_start[0] = 0;
    for (i = 1; i < m; i++)
        ws_start[i] = ws_start[i - 1] + c[i - 1];
    /* Масив ws_start заповнено */


    freopen("stones.dat", "r", stdin);  // Файл буде зчитуватися повторно

    scanf("%d%d", &n, &m);

    cnt2 = 0;   // Ініціалізація лічильника купи другого рівня
    for (i = 0; i < m; i++)
    {
        cnt[i] = 0; // Ініціалізація лічильників куп першого рівня
        heap2_town_index[i] = -1;   // Ініціалізація індексів
        heap2[i] = make_pair(-1, -1);   // Заздалегідь створюємо (поки що фіктивні) m елементів купи другого рівня: потім будемо лише змінювати першу і другу компоненту кожного елемента замість того, щоб створювати й видаляти щораз нові об’єкти
    }

    for (i = 0; i < n; i++) // Опрацювання подій
    {
        scanf("%d", &op);
        if (op == 1)
        {
            scanf("%d%d", &t, &w);
            t--;    // Нумерація міст у програмі з нуля, а у вхідному файлі — з одиниці
            insert(t, w);
        } else
            printf("%d\n", remove2());
    }

    return 0;
}
